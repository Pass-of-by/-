# 1、定义：
- 给定一些物品，每种物品只有一个，它们有重量（也有可能是体积，不过这不重要，这只是一个限制条件，下文用重量来代表），价值两种属性，现给你一个有装载重量限制的背包，要求在不超过最大装载质量的前提下使得放入的物品价值之和最大
# 2、对问题的思考
- 显然这个问题不能直接通过某种公式或准则求解，既然写在动态规划这一章，大家不妨思考一下这个问题与动态规划有什么联系
- 问题的难点在于我们不知道一件物品是否应该放入，或者说有一件非常”吸引人“（这里指重量小而且价值大）的物品我很想放进来，但可能它与其他的物品组合放进来后反而效果不好
- 换个角度思考问题，假设现在要去选择第i件物品，是不是又碰到了上面最后一段的问题？
- 那我这时候拼了，不管了，不考虑这件物品对后来的影响，我只考虑在第i件物品的**决策**结束后当前（前i件物品能获得的最大价值和）最优，那是不是一直这样下去为就能得到答案呢？从后来者的角度来讲是正确的（这里就是上一章讲到的最优子结构，即当前构成了最优）
- 只不过这时的解法有点粗糙，我们还需要细致一点，假设这时我们要对第i件物品进行决策（拿或不拿），并且我们已经计算出前i-1件物品能获得的最大值,则可以由前i-1件计算出前i件的最大价值（这里就是状态转移）
- 但这里还是有点粗糙，具体表现在怎么拿物品？更进一步，就算前i-1件的最大值已经算出来了，这时背包剩余的可装载质量是多少？需不需要换出物品？
# 3、基于多阶段状态转移的动态规划解法
- 首先需要明确前i件物品价值和的最大值计算出来后便不会再变
- 上述解法的思路已经很明确了，只需要加入更多的细节即可，前i件物品的最大价值和应该是随着决策的进行随之递增的，这是一个递增的序列，**我们加入对容积的描述**，到这里解法已经呼之欲出了
- 定义 **dp[i][j]** 为在质量限制为j的前提下，装入前i件物品能获得的最大价值（定义状态）
- 那么显然

<div align="center"> 
  dp[i][j]=max(dp[i-1][j-w[i]]+v[i],dp[i-1][j])
</div>

- 这里的意思是对于第i个物品，我拿的话就用**他的价值加上在j-w[i]重量限制下前i-1件物品的最大价值和**来计算出当前的最优解，如果不拿就直接用前i-1件的最大和就行了，这里两者显然要取最大值
# 4、疑惑
- 这里解释一下拿的话两个参数的确定（dp[i-1][j-w[i]]）
- 这里如果这里写从0到i-2的话，那么根据dp的定义，是不是中间就少了很多东西没有决策（这里写i-2的话就没有考虑第i-1件物品，相当于我把第i-1件给踢掉了，直接不管他了，这显然是不对的，写i-3也是一样的,以此类推）
- 那j-w[i]是怎么来的？
- 如果这里是更小的容量，那么拿了这件物品之后是不是就有更多闲置空间了，如果是更大的容量，那么这时的容量就不够了，不能够放下第i个物品，j-w[i]的话重量刚好能够容下第i个物品，不多也不少
# 5、代码
```
#include<iostream>
using namespace std;
const int M=205,N=35;
int w[N],v[N],dp[N][M];
int m,n;
int main()
{
    ios::sync_with_stdio(false);
    cin>>m>>n;
    for (int i=1;i<=n;++i){
        cin>>w[i]>>v[i];
    }
    for (int i=1;i<=n;++i){
        for (int j=1;j<=m;++j){
            if (j-w[i]>=0)
                dp[i][j]=max(dp[i-1][j],dp[i-1][j-w[i]]+v[i]);
            else
                dp[i][j]=dp[i-1][j];
        }
    }
    cout<<dp[n][m]<<endl;
    return 0;
}
```
- 时间复杂的：O(m*n)
- 空间复杂度：O(m*n)，n为物品数量，m为背包最大重量限制
- 实际上这一次的选择仅和上一次的结果有关，所以我们可以使用一维数组来代替二维数组，降低空间复杂度，但这里要从后往前递推，原因放在下一节解答
```
#include<iostream>
using namespace std;
const int M=205,N=35;
int w[N],v[N],dp[M];
int m,n;
int main()
{
    ios::sync_with_stdio(false);
    cin>>m>>n;
    for (int i=1;i<=n;++i){
        cin>>w[i]>>v[i];
    }
    for (int i=1;i<=n;++i){
        for (int j=m;j>=1;--j){
            if (j-w[i]>=0)
                dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
        }
    }
    cout<<dp[m]<<endl;
    return 0;
}
```
- 时间复杂的：O(m*n)
- 空间复杂度：O(m)，n为物品数量，m为背包最大重量限制

- 题目链接：[0-1背包问题，dotcpp](https://www.dotcpp.com/oj/problem2131.html)
# 6、其他
- 背包问题是一个应用广泛的组合优化的NP完全问题，现在有很多研究人员通过启发式算法来求解，目前已经得到了很好的效果
- 如果添加条件：可以对物品进行分割并获得等比例的价值，那么这个问题就变成了依次放入价值比最大的物品，不能完全放入则切割（贪心算法）
- 作为最基础的背包问题，这一节会讲的更详细一点
